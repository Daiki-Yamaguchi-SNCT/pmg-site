<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>3D Arena Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#000;}
#ui{
 position:fixed;
 top:10px; left:10px;
 color:#fff;
 font-family:sans-serif;
 font-size:18px;
}
</style>
</head>

<body>
<div id="ui">Score: <span id="score">0</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// =====================
// 基本セットアップ
// =====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // 明るい空

const camera = new THREE.PerspectiveCamera(
 75, innerWidth/innerHeight, 0.1, 1000
);
camera.position.set(0,6,10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// =====================
// ライト
// =====================
scene.add(new THREE.AmbientLight(0xffffff,0.7));

const dirLight = new THREE.DirectionalLight(0xffffff,1.2);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// =====================
// 床
// =====================
const floor = new THREE.Mesh(
 new THREE.PlaneGeometry(60,60),
 new THREE.MeshStandardMaterial({color:0x55aa55})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// =====================
// 背景オブジェクト（世界感）
// =====================
for(let i=0;i<40;i++){
 const obj = new THREE.Mesh(
  new THREE.BoxGeometry(1,Math.random()*4+1,1),
  new THREE.MeshStandardMaterial({color:0xcccccc})
 );
 obj.position.set(
  (Math.random()-0.5)*50,
  obj.geometry.parameters.height/2,
  (Math.random()-0.5)*50
 );
 scene.add(obj);
}

// =====================
// プレイヤー（仮キャラ）
// =====================
const player = new THREE.Mesh(
 new THREE.SphereGeometry(0.7,20,20),
 new THREE.MeshStandardMaterial({color:0xffffff})
);
player.position.y = 0.7;
scene.add(player);

// =====================
// 敵
// =====================
const enemies = [];

function spawnEnemy(){
 const e = new THREE.Mesh(
  new THREE.BoxGeometry(0.9,0.9,0.9),
  new THREE.MeshStandardMaterial({color:0xff3333})
 );
 e.position.set(
  (Math.random()-0.5)*30,
  0.45,
  (Math.random()-0.5)*30
 );
 e.userData = {
  type: Math.floor(Math.random()*3),
  speed: 2 + Math.random()*2,
  t: Math.random()*5
 };
 scene.add(e);
 enemies.push(e);
}
setInterval(spawnEnemy, 1200);

// =====================
// 入力（WASD＋タッチ）
// =====================
const key = {};
addEventListener("keydown",e=>key[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>key[e.key.toLowerCase()]=false);

let touchX=0, touchY=0;
addEventListener("touchmove",e=>{
 const t=e.touches[0];
 touchX=(t.clientX/innerWidth-0.5)*2;
 touchY=(t.clientY/innerHeight-0.5)*2;
},{passive:false});

// =====================
// スコア
// =====================
let score=0;
const scoreEl=document.getElementById("score");

// =====================
// メインループ（時空歪み対策）
// =====================
let last=performance.now();
function loop(now){
 const dt=(now-last)/1000;
 last=now;

 update(dt);
 renderer.render(scene,camera);
 requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================
// 更新処理
// =====================
function update(dt){
 const speed=6;

 // 移動
 if(key.w) player.position.z-=speed*dt;
 if(key.s) player.position.z+=speed*dt;
 if(key.a) player.position.x-=speed*dt;
 if(key.d) player.position.x+=speed*dt;

 player.position.x+=touchX*speed*dt;
 player.position.z+=touchY*speed*dt;

 // カメラ追従
 camera.position.x+= (player.position.x-camera.position.x)*0.1;
 camera.position.z+= (player.position.z+10-camera.position.z)*0.1;
 camera.lookAt(player.position);

 // 敵AI
 enemies.forEach(e=>{
  const dx=player.position.x-e.position.x;
  const dz=player.position.z-e.position.z;
  const dist=Math.hypot(dx,dz)+0.001;

  if(e.userData.type===0){
   e.position.x+=dx/dist*e.userData.speed*dt;
   e.position.z+=dz/dist*e.userData.speed*dt;
  }else if(e.userData.type===1){
   e.userData.t+=dt;
   if(Math.sin(e.userData.t)>0){
    e.position.x+=dx/dist*e.userData.speed*dt;
    e.position.z+=dz/dist*e.userData.speed*dt;
   }
  }else{
   e.userData.t+=dt*5;
   e.position.x+=Math.sin(e.userData.t)*3*dt;
   e.position.z+=dz/dist*e.userData.speed*dt;
  }

  // 当たり判定
  if(dist<1){
   score=0;
   scoreEl.textContent=0;
   player.position.set(0,0.7,0);
  }
 });

 score+=dt*10;
 scoreEl.textContent=Math.floor(score);
}

// =====================
// リサイズ
// =====================
addEventListener("resize",()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
