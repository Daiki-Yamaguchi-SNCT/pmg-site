<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>3D Game</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
#ui {
 position:fixed;
 left:10px;
 top:10px;
 color:white;
 font-family:sans-serif;
}
</style>
</head>

<body>
<div id="ui">Score: <span id="score">0</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
// ===== 基本 =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222244);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,5,8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ===== ライト =====
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,5);
scene.add(light);

// ===== 床 =====
const floor = new THREE.Mesh(
 new THREE.PlaneGeometry(50,50),
 new THREE.MeshStandardMaterial({color:0x334455})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// ===== プレイヤー（キャラ代わり）=====
const player = new THREE.Mesh(
 new THREE.SphereGeometry(0.6,16,16),
 new THREE.MeshStandardMaterial({color:0x44ff88})
);
player.position.y = 0.6;
scene.add(player);

// ===== 敵 =====
const enemies = [];

function spawnEnemy(){
 const e = new THREE.Mesh(
  new THREE.BoxGeometry(0.8,0.8,0.8),
  new THREE.MeshStandardMaterial({color:0xff4444})
 );

 e.position.set(
  (Math.random()-0.5)*20,
  0.5,
  (Math.random()-0.5)*20
 );

 e.userData = {
  type: Math.floor(Math.random()*3),
  speed: 2 + Math.random()*2,
  t: Math.random()*10
 };

 scene.add(e);
 enemies.push(e);
}

setInterval(spawnEnemy, 1200);

// ===== 入力 =====
const key = {};
addEventListener("keydown", e=> key[e.key.toLowerCase()]=true);
addEventListener("keyup", e=> key[e.key.toLowerCase()]=false);

// タッチ
let touchX=0, touchY=0;
addEventListener("touchmove", e=>{
 const t = e.touches[0];
 touchX = (t.clientX/innerWidth -0.5)*2;
 touchY = (t.clientY/innerHeight-0.5)*2;
});

// ===== スコア =====
let score=0;
const scoreEl = document.getElementById("score");

// ===== ループ（時空歪み対策）=====
let last = performance.now();

function loop(now){
 const dt = (now-last)/1000;
 last = now;

 update(dt);
 renderer.render(scene,camera);
 requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ===== 更新 =====
function update(dt){

 const speed = 6;

 // WASD
 if(key.w) player.position.z -= speed*dt;
 if(key.s) player.position.z += speed*dt;
 if(key.a) player.position.x -= speed*dt;
 if(key.d) player.position.x += speed*dt;

 // タッチ
 player.position.x += touchX * speed * dt;
 player.position.z += touchY * speed * dt;

 // カメラ追従
 camera.position.x += (player.position.x - camera.position.x)*0.1;
 camera.position.z += (player.position.z + 8 - camera.position.z)*0.1;
 camera.lookAt(player.position);

 // 敵AI
 enemies.forEach(e=>{
  const dx = player.position.x - e.position.x;
  const dz = player.position.z - e.position.z;
  const dist = Math.sqrt(dx*dx + dz*dz);

  if(e.userData.type===0){
   // 直線追尾
   e.position.x += dx/dist * e.userData.speed * dt;
   e.position.z += dz/dist * e.userData.speed * dt;
  }

  if(e.userData.type===1){
   // 遅延追尾
   e.userData.t += dt;
   if(Math.sin(e.userData.t)>0){
    e.position.x += dx/dist * e.userData.speed * dt;
    e.position.z += dz/dist * e.userData.speed * dt;
   }
  }

  if(e.userData.type===2){
   // ジグザグ
   e.userData.t += dt*5;
   e.position.x += Math.sin(e.userData.t)*3*dt;
   e.position.z += dz/dist * e.userData.speed * dt;
  }

  // 当たり判定
  if(dist<1){
   score=0;
   scoreEl.textContent=score;
   player.position.set(0,0.6,0);
  }
 });

 // スコア加算
 score += dt*10;
 scoreEl.textContent = Math.floor(score);
}

// ===== リサイズ =====
addEventListener("resize",()=>{
 camera.aspect = innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
