<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Underwater 3D Arena</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#001b2e;}
#ui{position:fixed;top:10px;left:10px;color:#e8f6ff;font-family:sans-serif;font-size:18px}
</style>
</head>
<body>
<div id="ui">Score: <span id="score">0</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
// =====================
// シーン基本
// =====================
const scene = new THREE.Scene();
// 海中フォグ（端を隠す）
scene.fog = new THREE.Fog(0x0b3c5d, 8, 35);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,5,10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// =====================
// ライト（海中っぽく）
// =====================
scene.add(new THREE.AmbientLight(0x88ccee, 0.8));
const dir = new THREE.DirectionalLight(0xaadfff, 0.9);
dir.position.set(5,12,5);
scene.add(dir);

// =====================
// スカイドーム（水のボリューム）
// =====================
const domeGeo = new THREE.SphereGeometry(80, 32, 32);
const domeMat = new THREE.MeshBasicMaterial({
  color: 0x0b3c5d, side: THREE.BackSide
});
scene.add(new THREE.Mesh(domeGeo, domeMat));

// =====================
// 海底
// =====================
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(80,80),
  new THREE.MeshStandardMaterial({color:0x1f6f8b, roughness:1})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// =====================
// 海中オブジェクト（岩・海藻）
// =====================
for(let i=0;i<45;i++){
  const rock = new THREE.Mesh(
    new THREE.DodecahedronGeometry(Math.random()*1.2+0.6),
    new THREE.MeshStandardMaterial({color:0x445566, roughness:1})
  );
  rock.position.set((Math.random()-0.5)*60, 0.6, (Math.random()-0.5)*60);
  scene.add(rock);
}
for(let i=0;i<60;i++){
  const kelp = new THREE.Mesh(
    new THREE.CylinderGeometry(0.1,0.2,Math.random()*4+2,6),
    new THREE.MeshStandardMaterial({color:0x2e8b57})
  );
  kelp.position.set((Math.random()-0.5)*60, (kelp.geometry.parameters.height/2), (Math.random()-0.5)*60);
  scene.add(kelp);
}

// =====================
// プレイヤー（仮キャラ）
// =====================
const player = new THREE.Mesh(
  new THREE.SphereGeometry(0.7,20,20),
  new THREE.MeshStandardMaterial({color:0xffffff})
);
player.position.y = 0.7;
scene.add(player);

// =====================
// 敵
// =====================
const enemies = [];
function spawnEnemy(){
  const e = new THREE.Mesh(
    new THREE.BoxGeometry(0.9,0.9,0.9),
    new THREE.MeshStandardMaterial({color:0xff4444})
  );
  e.position.set((Math.random()-0.5)*30, 0.45, (Math.random()-0.5)*30);
  e.userData = {
    type: Math.floor(Math.random()*3),
    speed: 1.8 + Math.random()*2.2,
    t: Math.random()*5
  };
  scene.add(e);
  enemies.push(e);
}
setInterval(spawnEnemy, 1200);

// =====================
// 入力（WASD＋タッチ）
// =====================
const key = {};
addEventListener("keydown",e=>key[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>key[e.key.toLowerCase()]=false);

let touchX=0, touchY=0;
addEventListener("touchmove",e=>{
  const t=e.touches[0];
  touchX=(t.clientX/innerWidth-0.5)*2;
  touchY=(t.clientY/innerHeight-0.5)*2;
},{passive:false});

// =====================
// スコア
// =====================
let score=0;
const scoreEl=document.getElementById("score");

// =====================
// ループ（dt固定）
// =====================
let last=performance.now();
function loop(now){
  const dt=(now-last)/1000;
  last=now;
  update(dt);
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================
// 更新
// =====================
function update(dt){
  const speed=6;

  // 移動（海中なので少し慣性）
  let vx=0, vz=0;
  if(key.w) vz-=1;
  if(key.s) vz+=1;
  if(key.a) vx-=1;
  if(key.d) vx+=1;
  player.position.x += (vx + touchX) * speed * dt;
  player.position.z += (vz + touchY) * speed * dt;

  // カメラ追従
  camera.position.x += (player.position.x-camera.position.x)*0.08;
  camera.position.z += (player.position.z+10-camera.position.z)*0.08;
  camera.lookAt(player.position);

  // 敵AI（3種）
  enemies.forEach(e=>{
    const dx=player.position.x-e.position.x;
    const dz=player.position.z-e.position.z;
    const dist=Math.hypot(dx,dz)+0.001;

    if(e.userData.type===0){
      e.position.x+=dx/dist*e.userData.speed*dt;
      e.position.z+=dz/dist*e.userData.speed*dt;
    }else if(e.userData.type===1){
      e.userData.t+=dt;
      if(Math.sin(e.userData.t)>0){
        e.position.x+=dx/dist*e.userData.speed*dt;
        e.position.z+=dz/dist*e.userData.speed*dt;
      }
    }else{
      e.userData.t+=dt*5;
      e.position.x+=Math.sin(e.userData.t)*3*dt;
      e.position.z+=dz/dist*e.userData.speed*dt;
    }

    // 当たり
    if(dist<1){
      score=0;
      scoreEl.textContent=0;
      player.position.set(0,0.7,0);
    }
  });

  score+=dt*10;
  scoreEl.textContent=Math.floor(score);
}

// =====================
// リサイズ
// =====================
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
