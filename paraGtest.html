<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Underwater Arena</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#001b2e;}
#ui{position:fixed;top:10px;left:10px;color:#e8f6ff;font-family:sans-serif;font-size:18px}
#msg{position:fixed;top:40px;left:10px;color:#ffd;font-family:sans-serif}
</style>
</head>
<body>
<div id="ui">Score: <span id="score">0</span></div>
<div id="msg"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

<script>

const gltfLoader = new THREE.GLTFLoader();
let enemyModel = null;

// 先にGLB読み込み（ゲーム開始時）
gltfLoader.load("./models/hara.glb", (gltf)=>{
  enemyModel = gltf.scene;
});

// =====================
// シーン
// =====================
const scene=new THREE.Scene();
// フォグを深く・遠くまで（境界を消す）
scene.fog=new THREE.FogExp2(0x0b3c5d, 0.035);

const camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
camera.position.set(0,5,10);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

// =====================
// ライト（海中）
// =====================
scene.add(new THREE.AmbientLight(0x88ccee,0.9));
const dir=new THREE.DirectionalLight(0xaadfff,0.7);
dir.position.set(5,12,5);
scene.add(dir);

// =====================
// スカイドーム（グラデーション風）
// =====================
const domeGeo=new THREE.SphereGeometry(120,32,32);
const domeMat=new THREE.MeshBasicMaterial({
  color:0x0b3c5d,
  side:THREE.BackSide
});
const dome=new THREE.Mesh(domeGeo,domeMat);
scene.add(dome);

// =====================
// 海底（端が見えないよう大きく）
// =====================
const floor=new THREE.Mesh(
 new THREE.PlaneGeometry(200,200),
 new THREE.MeshStandardMaterial({color:0x1f6f8b,roughness:1})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

// =====================
// 障害物（岩のみ当たり判定あり）
// =====================
const obstacles=[];
function addObstacle(mesh,radius){
 mesh.userData.radius=radius;
 obstacles.push(mesh);
 scene.add(mesh);
}

// 岩
for(let i=0;i<35;i++){
 const r=Math.random()*1.2+0.8;
 const rock=new THREE.Mesh(
  new THREE.DodecahedronGeometry(r),
  new THREE.MeshStandardMaterial({color:0x445566,roughness:1})
 );
 rock.position.set((Math.random()-0.5)*120,r,(Math.random()-0.5)*120);
 addObstacle(rock,r);
}

// =====================
// 海藻（当たり判定なし・背高・揺れる）
// =====================
const kelps=[];
for(let i=0;i<70;i++){
 const h=Math.random()*10+8; // 高くする
 const kelp=new THREE.Mesh(
  new THREE.CylinderGeometry(0.15,0.3,h,6,1,true),
  new THREE.MeshStandardMaterial({color:0x2e8b57})
 );
 kelp.position.set((Math.random()-0.5)*120,h/2,(Math.random()-0.5)*120);
 kelp.userData={t:Math.random()*10,height:h};
 scene.add(kelp);
 kelps.push(kelp);
}

// =====================
// プレイヤー
// =====================
const player=new THREE.Mesh(
 new THREE.SphereGeometry(0.7,20,20),
 new THREE.MeshStandardMaterial({color:0xffffff})
);
player.position.y=0.7;
scene.add(player);

// =====================
// 敵
// =====================
let enemies=[];
function spawnEnemy(){

  if(!enemyModel) return; // まだ読み込み中なら出さない

  const e = enemyModel.clone(true);

  e.position.set(
    (Math.random()-0.5)*40,
    0,
    (Math.random()-0.5)*40
  );

  e.scale.set(1,1,1);

  e.userData = {
    type: Math.floor(Math.random()*3),
    speed: 1.8 + Math.random()*2.2,
    t: Math.random()*5
  };

  scene.add(e);
  enemies.push(e);
}

setInterval(spawnEnemy,1200);

// =====================
// 入力
// =====================
const key={};
addEventListener("keydown",e=>key[e.key.toLowerCase()]=true);
addEventListener("keyup",e=>key[e.key.toLowerCase()]=false);

let touchX=0,touchY=0;
addEventListener("touchmove",e=>{
 const t=e.touches[0];
 touchX=(t.clientX/innerWidth-0.5)*2;
 touchY=(t.clientY/innerHeight-0.5)*2;
},{passive:false});

// =====================
// スコア & 状態
// =====================
let score=0;
const scoreEl=document.getElementById("score");
const msg=document.getElementById("msg");
let invincible=0;
const SAFE_RADIUS=3;

// =====================
// ループ
// =====================
let last=performance.now();
function loop(now){
 const dt=(now-last)/1000; last=now;
 update(dt);
 renderer.render(scene,camera);
 requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================
// 更新
// =====================
function update(dt){
 const speed=6;

 // 移動
 let vx=0,vz=0;
 if(key.w) vz-=1;
 if(key.s) vz+=1;
 if(key.a) vx-=1;
 if(key.d) vx+=1;
 player.position.x+=(vx+touchX)*speed*dt;
 player.position.z+=(vz+touchY)*speed*dt;

 // 岩当たり判定（押し戻し）
 obstacles.forEach(o=>{
  const dx=player.position.x-o.position.x;
  const dz=player.position.z-o.position.z;
  const dist=Math.hypot(dx,dz);
  const min=o.userData.radius+0.7;
  if(dist<min){
   const nx=dx/(dist+0.001), nz=dz/(dist+0.001);
   player.position.x=o.position.x+nx*min;
   player.position.z=o.position.z+nz*min;
  }
 });

 // 海藻アニメーション（揺れ）
 kelps.forEach(k=>{
  k.userData.t+=dt;
  k.rotation.z=Math.sin(k.userData.t)*0.15;
 });

 // カメラ
 camera.position.x+=(player.position.x-camera.position.x)*0.08;
 camera.position.z+=(player.position.z+10-camera.position.z)*0.08;
 camera.lookAt(player.position);

 // 敵AI
 enemies.forEach(e=>{
  const dx=player.position.x-e.position.x;
  const dz=player.position.z-e.position.z;
  const dist=Math.hypot(dx,dz)+0.001;

  if(e.userData.type===0){
   e.position.x+=dx/dist*e.userData.speed*dt;
   e.position.z+=dz/dist*e.userData.speed*dt;
  }else if(e.userData.type===1){
   e.userData.t+=dt;
   if(Math.sin(e.userData.t)>0){
    e.position.x+=dx/dist*e.userData.speed*dt;
    e.position.z+=dz/dist*e.userData.speed*dt;
   }
  }else{
   e.userData.t+=dt*5;
   e.position.x+=Math.sin(e.userData.t)*3*dt;
   e.position.z+=dz/dist*e.userData.speed*dt;
  }

  if(invincible>0 && dist<SAFE_RADIUS){
   e.position.x-=dx/dist*5*dt;
   e.position.z-=dz/dist*5*dt;
  }

  if(invincible<=0 && dist<1){
   gameOver();
  }
 });

 if(invincible>0){
  invincible-=dt;
  msg.textContent="INVINCIBLE";
 }else{
  msg.textContent="";
 }

 score+=dt*10;
 scoreEl.textContent=Math.floor(score);
}

// =====================
// ゲームオーバー
// =====================
function gameOver(){
 score=0; scoreEl.textContent=0;
 player.position.set(0,0.7,0);
 enemies.forEach(e=>scene.remove(e));
 enemies=[];
 invincible=3;
}

// =====================
// リサイズ
// =====================
addEventListener("resize",()=>{
 camera.aspect=innerWidth/innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
