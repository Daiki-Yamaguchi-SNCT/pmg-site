<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>Underwater Arena - Battle Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#001b2e;font-family:'Arial',sans-serif;}
#ui{position:fixed;top:10px;left:10px;color:#e8f6ff;font-size:20px;text-shadow:2px 2px 4px #000;z-index:100;}
#combo{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#ffdd00;font-size:48px;font-weight:bold;text-shadow:3px 3px 6px #000;pointer-events:none;opacity:0;transition:opacity 0.3s;}
#msg{position:fixed;top:80px;left:10px;color:#ffd;font-size:28px;font-weight:bold;text-shadow:2px 2px 4px #000;}
#highscore{position:fixed;top:45px;left:10px;color:#aaddff;font-size:14px;text-shadow:1px 1px 2px #000;}
#minimap{position:fixed;top:10px;right:10px;width:180px;height:180px;border:3px solid #e8f6ff;background:rgba(11,60,93,0.8);border-radius:10px;box-shadow:0 0 20px rgba(136,204,238,0.5);}
#controls{position:fixed;bottom:10px;left:10px;color:#aaddff;font-size:13px;text-shadow:1px 1px 2px #000;max-width:350px;line-height:1.6;}
#achievements{position:fixed;bottom:10px;right:10px;color:#e8f6ff;font-size:12px;text-shadow:1px 1px 2px #000;text-align:right;max-width:250px;background:rgba(0,27,46,0.7);padding:10px;border-radius:5px;}
#boss-health{position:fixed;top:50px;left:50%;transform:translateX(-50%);width:400px;height:30px;background:rgba(0,0,0,0.7);border:2px solid #ff4444;border-radius:5px;display:none;}
#boss-health-bar{height:100%;background:linear-gradient(90deg,#ff0000,#ff8800);border-radius:3px;transition:width 0.3s;}
#boss-name{position:fixed;top:30px;left:50%;transform:translateX(-50%);color:#ff4444;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px #000;display:none;}
#special-meter{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);width:200px;height:20px;background:rgba(0,0,0,0.7);border:2px solid #ffdd00;border-radius:5px;}
#special-bar{height:100%;background:linear-gradient(90deg,#ffdd00,#ff8800);border-radius:3px;transition:width 0.1s;}
#special-text{position:fixed;bottom:35px;left:50%;transform:translateX(-50%);color:#ffdd00;font-size:14px;font-weight:bold;text-shadow:1px 1px 2px #000;}
</style>
</head>
<body>
<div id="ui">
  „Çπ„Ç≥„Ç¢: <span id="score">0</span> | 
  „Ç≥„É≥„Éú: <span id="comboCount">0</span>x | 
  Wave: <span id="wave">1</span>
</div>
<div id="highscore">„Éè„Ç§„Çπ„Ç≥„Ç¢: <span id="highscoreVal">0</span></div>
<div id="msg"></div>
<div id="combo"></div>
<canvas id="minimap"></canvas>
<div id="controls">
  <b>WASD:</b> ÁßªÂãï | <b>„Éû„Ç¶„Çπ:</b> ÁÖßÊ∫ñ | <b>„ÇØ„É™„ÉÉ„ÇØ:</b> Â∞ÑÊíÉ<br>
  <b>„Çπ„Éö„Éº„Çπ:</b> „ÉÄ„ÉÉ„Ç∑„É• | <b>Shift:</b> ÂøÖÊÆ∫ÊäÄÔºà„Ç≤„Éº„Ç∏MAXÊôÇÔºâ<br>
  Êïµ„ÇíÂÄí„Åó„Å¶„Ç≥„É≥„ÉúÔºÜ„Çπ„Ç≥„Ç¢„ÇíÁ®º„ÅíÔºÅ
</div>
<div id="achievements">
  <div style="font-weight:bold;margin-bottom:5px;">üèÜ ÂÆüÁ∏æ</div>
  <div id="achievement-list"></div>
</div>
<div id="boss-name"></div>
<div id="boss-health">
  <div id="boss-health-bar"></div>
</div>
<div id="special-text">ÂøÖÊÆ∫ÊäÄ„Ç≤„Éº„Ç∏</div>
<div id="special-meter">
  <div id="special-bar"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>

// =====================
// „Ç™„Éº„Éá„Ç£„Ç™„Ç∑„Çπ„ÉÜ„É†
// =====================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  const sounds = {
    shoot: () => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.05);
    },
    coin: () => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.setValueAtTime(800, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.15);
    },
    powerup: () => {
      [0, 0.05, 0.1].forEach((delay, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = 600 + i * 400;
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime + delay);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.2);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.2);
      });
    },
    hit: () => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    },
    dash: () => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'square';
      osc.frequency.value = 400;
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.1);
    },
    enemyKill: (combo) => {
      const freq = 300 + combo * 50;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.frequency.value = Math.min(freq, 1500);
      gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
    },
    bossHit: () => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'triangle';
      osc.frequency.value = 100;
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.4);
    },
    bossSpawn: () => {
      [100, 150, 200, 250].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        const delay = i * 0.1;
        gain.gain.setValueAtTime(0.25, audioCtx.currentTime + delay);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.3);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.3);
      });
    },
    special: () => {
      [0, 0.05, 0.1, 0.15, 0.2].forEach((delay, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sawtooth';
        osc.frequency.value = 200 + i * 200;
        gain.gain.setValueAtTime(0.3, audioCtx.currentTime + delay);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + delay + 0.3);
        osc.start(audioCtx.currentTime + delay);
        osc.stop(audioCtx.currentTime + delay + 0.3);
      });
    }
  };
  
  if(sounds[type]) sounds[type]();
}

// =====================
// „Ç∑„Éº„É≥
// =====================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0b3c5d, 0.02);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 12, 18);

const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// =====================
// „É©„Ç§„Éà
// =====================
scene.add(new THREE.AmbientLight(0x88ccee, 0.7));
const dir = new THREE.DirectionalLight(0xaadfff, 0.9);
dir.position.set(5, 15, 5);
dir.castShadow = true;
scene.add(dir);

// =====================
// „Ç¢„É™„Éº„Éä„ÅÆÂ¢ÉÁïåÂ£Å
// =====================
const ARENA_SIZE = 60;
const wallHeight = 8;
const wallMaterial = new THREE.MeshStandardMaterial({
  color: 0x1a4d5e,
  transparent: true,
  opacity: 0.6,
  roughness: 0.8
});

const walls = [];
const wallThickness = 2;

const northWall = new THREE.Mesh(
  new THREE.BoxGeometry(ARENA_SIZE * 2 + wallThickness * 2, wallHeight, wallThickness),
  wallMaterial
);
northWall.position.set(0, wallHeight/2, -ARENA_SIZE);
scene.add(northWall);
walls.push({mesh: northWall, normal: new THREE.Vector3(0, 0, 1)});

const southWall = new THREE.Mesh(
  new THREE.BoxGeometry(ARENA_SIZE * 2 + wallThickness * 2, wallHeight, wallThickness),
  wallMaterial
);
southWall.position.set(0, wallHeight/2, ARENA_SIZE);
scene.add(southWall);
walls.push({mesh: southWall, normal: new THREE.Vector3(0, 0, -1)});

const westWall = new THREE.Mesh(
  new THREE.BoxGeometry(wallThickness, wallHeight, ARENA_SIZE * 2),
  wallMaterial
);
westWall.position.set(-ARENA_SIZE, wallHeight/2, 0);
scene.add(westWall);
walls.push({mesh: westWall, normal: new THREE.Vector3(1, 0, 0)});

const eastWall = new THREE.Mesh(
  new THREE.BoxGeometry(wallThickness, wallHeight, ARENA_SIZE * 2),
  wallMaterial
);
eastWall.position.set(ARENA_SIZE, wallHeight/2, 0);
scene.add(eastWall);
walls.push({mesh: eastWall, normal: new THREE.Vector3(-1, 0, 0)});

walls.forEach(wall => {
  const light = new THREE.PointLight(0x00ddff, 0.5, 20);
  light.position.copy(wall.mesh.position);
  scene.add(light);
});

// =====================
// „Çπ„Ç´„Ç§„Éâ„Éº„É†
// =====================
const domeGeo = new THREE.SphereGeometry(150, 32, 32);
const domeMat = new THREE.MeshBasicMaterial({
  color: 0x0b3c5d,
  side: THREE.BackSide
});
const dome = new THREE.Mesh(domeGeo, domeMat);
scene.add(dome);

// =====================
// Êµ∑Â∫ï
// =====================
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(ARENA_SIZE * 2.5, ARENA_SIZE * 2.5, 20, 20),
  new THREE.MeshStandardMaterial({
    color: 0x1f6f8b,
    roughness: 1
  })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

const borderLine = new THREE.LineLoop(
  new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-ARENA_SIZE, 0.1, -ARENA_SIZE),
    new THREE.Vector3(ARENA_SIZE, 0.1, -ARENA_SIZE),
    new THREE.Vector3(ARENA_SIZE, 0.1, ARENA_SIZE),
    new THREE.Vector3(-ARENA_SIZE, 0.1, ARENA_SIZE),
  ]),
  new THREE.LineBasicMaterial({color: 0x00ddff, linewidth: 2})
);
scene.add(borderLine);

// =====================
// ÈöúÂÆ≥Áâ©ÔºàÂ≤©Ôºâ
// =====================
const obstacles = [];
function addObstacle(mesh, radius) {
  mesh.userData.radius = radius;
  mesh.castShadow = true;
  obstacles.push(mesh);
  scene.add(mesh);
}

for(let i = 0; i < 25; i++) {
  const r = Math.random() * 1.5 + 1.0;
  const rock = new THREE.Mesh(
    new THREE.DodecahedronGeometry(r, 1),
    new THREE.MeshStandardMaterial({
      color: 0x445566,
      roughness: 0.9,
      metalness: 0.1
    })
  );
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * (ARENA_SIZE - 10) + 5;
  rock.position.set(
    Math.cos(angle) * dist,
    r,
    Math.sin(angle) * dist
  );
  addObstacle(rock, r);
}

// =====================
// Êµ∑ËóªÔºàÈ´ò„Åè„ÉªÂØÜÂ∫¶‰Ωé„ÅèÔºâ
// =====================
const kelps = [];
for(let i = 0; i < 30; i++) {
  const h = Math.random() * 12 + 10; // 10-22m„ÅÆÈ´ò„Åï
  const kelp = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15, 0.3, h, 8, 1, true),
    new THREE.MeshStandardMaterial({color: 0x2e8b57})
  );
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * (ARENA_SIZE - 5);
  kelp.position.set(
    Math.cos(angle) * dist,
    h/2,
    Math.sin(angle) * dist
  );
  kelp.userData = {t: Math.random() * 10, height: h};
  scene.add(kelp);
  kelps.push(kelp);
}

// =====================
// „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÔºàÊ≥°Ôºâ
// =====================
const bubbles = [];
for(let i = 0; i < 80; i++) {
  const bubble = new THREE.Mesh(
    new THREE.SphereGeometry(0.1 + Math.random() * 0.25, 8, 8),
    new THREE.MeshBasicMaterial({
      color: 0xaaddff,
      transparent: true,
      opacity: 0.5
    })
  );
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * ARENA_SIZE;
  bubble.position.set(
    Math.cos(angle) * dist,
    Math.random() * 25,
    Math.sin(angle) * dist
  );
  bubble.userData = {speed: 0.5 + Math.random() * 0.8};
  scene.add(bubble);
  bubbles.push(bubble);
}

// =====================
// „Éó„É¨„Ç§„É§„Éº
// =====================
const player = new THREE.Mesh(
  new THREE.SphereGeometry(0.7, 24, 24),
  new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x4444ff,
    emissiveIntensity: 0.3,
    metalness: 0.5
  })
);
player.position.y = 0.7;
player.castShadow = true;
scene.add(player);

const playerLight = new THREE.PointLight(0x88ccff, 1.5, 15);
player.add(playerLight);

// ÁÖßÊ∫ñ„É¨„ÉÜ„Ç£„ÇØ„É´
const reticle = new THREE.Mesh(
  new THREE.RingGeometry(0.3, 0.4, 16),
  new THREE.MeshBasicMaterial({
    color: 0x00ff00,
    transparent: true,
    opacity: 0.7
  })
);
reticle.rotation.x = -Math.PI/2;
reticle.position.y = 0.1;
scene.add(reticle);

// =====================
// Âºæ‰∏∏„Ç∑„Çπ„ÉÜ„É†
// =====================
let bullets = [];
let shootCooldown = 0;
const SHOOT_COOLDOWN = 0.15;

function shootBullet(targetX, targetZ) {
  if(shootCooldown > 0) return;
  
  const bullet = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 8, 8),
    new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 1
    })
  );
  
  bullet.position.copy(player.position);
  const dx = targetX - player.position.x;
  const dz = targetZ - player.position.z;
  const dist = Math.hypot(dx, dz);
  
  bullet.userData = {
    vx: dx / dist * 40,
    vz: dz / dist * 40,
    life: 2
  };
  
  scene.add(bullet);
  bullets.push(bullet);
  shootCooldown = SHOOT_COOLDOWN;
  playSound('shoot');
}

// =====================
// ÂøÖÊÆ∫ÊäÄ
// =====================
let specialMeter = 0;
let specialActive = false;

function activateSpecial() {
  if(specialMeter < 100 || specialActive) return;
  
  specialMeter = 0;
  specialActive = true;
  playSound('special');
  
  // ÂÖ®ÊñπÂêëÂºæ‰∏∏
  for(let i = 0; i < 24; i++) {
    const angle = (i / 24) * Math.PI * 2;
    const bullet = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 8, 8),
      new THREE.MeshBasicMaterial({
        color: 0xffff00,
        emissive: 0xffff00,
        emissiveIntensity: 1
      })
    );
    
    bullet.position.copy(player.position);
    bullet.userData = {
      vx: Math.cos(angle) * 35,
      vz: Math.sin(angle) * 35,
      life: 3,
      damage: 3
    };
    
    scene.add(bullet);
    bullets.push(bullet);
  }
  
  setTimeout(() => { specialActive = false; }, 100);
}

// =====================
// „Ç≥„Ç§„É≥
// =====================
let coins = [];
function spawnCoin() {
  const coin = new THREE.Mesh(
    new THREE.CylinderGeometry(0.5, 0.5, 0.15, 20),
    new THREE.MeshStandardMaterial({
      color: 0xffdd00,
      emissive: 0xffaa00,
      emissiveIntensity: 0.6,
      metalness: 0.9
    })
  );
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * (ARENA_SIZE - 5);
  coin.position.set(
    Math.cos(angle) * dist,
    0.5,
    Math.sin(angle) * dist
  );
  coin.rotation.x = Math.PI/2;
  coin.userData = {t: Math.random() * 10};
  coin.castShadow = true;
  scene.add(coin);
  coins.push(coin);
}

// =====================
// „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó
// =====================
let powerups = [];
const powerupTypes = {
  invincible: {color: 0x00ddff, emissive: 0x00aaff},
  speed: {color: 0x00ff88, emissive: 0x00dd66},
  rapidfire: {color: 0xff00ff, emissive: 0xdd00dd}
};

function spawnPowerup() {
  const types = Object.keys(powerupTypes);
  const type = types[Math.floor(Math.random() * types.length)];
  const config = powerupTypes[type];
  
  // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„ÅØÊòüÂûãÔºàÊïµ„Å®Âå∫Âà•Ôºâ
  const starGroup = new THREE.Group();
  
  // ‰∏≠Â§Æ„ÅÆÁêÉ
  const core = new THREE.Mesh(
    new THREE.SphereGeometry(0.4, 16, 16),
    new THREE.MeshStandardMaterial({
      color: config.color,
      emissive: config.emissive,
      emissiveIntensity: 0.9,
      metalness: 0.8
    })
  );
  starGroup.add(core);
  
  // 8ÊñπÂêë„ÅÆÂÖâÁ∑ö
  const rayGeometry = new THREE.ConeGeometry(0.1, 0.6, 4);
  for(let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const ray = new THREE.Mesh(
      rayGeometry,
      new THREE.MeshStandardMaterial({
        color: config.color,
        emissive: config.emissive,
        emissiveIntensity: 1.0
      })
    );
    ray.position.x = Math.cos(angle) * 0.5;
    ray.position.z = Math.sin(angle) * 0.5;
    ray.rotation.z = -angle + Math.PI / 2;
    ray.rotation.x = Math.PI / 2;
    starGroup.add(ray);
  }
  
  const angle = Math.random() * Math.PI * 2;
  const dist = Math.random() * (ARENA_SIZE - 10) + 5;
  starGroup.position.set(
    Math.cos(angle) * dist,
    0.5,
    Math.sin(angle) * dist
  );
  starGroup.userData = {t: Math.random() * 10, type: type};
  scene.add(starGroup);
  powerups.push(starGroup);
}

// =====================
// Êïµ„Ç∑„Çπ„ÉÜ„É†
// =====================
let enemies = [];
let waveNumber = 1;
let enemiesInWave = 0;
let enemiesKilledInWave = 0;
let boss = null;

const enemyTypes = {
  chaser: {color: 0xff4444, speed: 2.5, health: 2, size: 0.9, points: 10},
  tank: {color: 0xff8844, speed: 1.5, health: 5, size: 1.3, points: 30},
  speedy: {color: 0xffaa44, speed: 4.0, health: 1, size: 0.7, points: 20},
  sniper: {color: 0xff44aa, speed: 1.8, health: 3, size: 0.8, points: 25}
};

function spawnEnemy(type = null) {
  // Êïµ„ÅÆÊúÄÂ§ßÊï∞„ÇíÂà∂Èôê„Åó„Å¶„Éï„É™„Éº„Ç∫Èò≤Ê≠¢
  if(enemies.length >= 40) return;
  
  if(!type) {
    const types = Object.keys(enemyTypes);
    type = types[Math.floor(Math.random() * types.length)];
  }
  
  const config = enemyTypes[type];
  
  // Êïµ„ÅØ„Éà„Ç≤„Éà„Ç≤„ÅÆÂΩ¢Áä∂Ôºà„Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó„Å®Âå∫Âà•Ôºâ
  const enemyGroup = new THREE.Group();
  
  // „É°„Ç§„É≥„Éú„Éá„Ç£
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(config.size, config.size, config.size),
    new THREE.MeshStandardMaterial({
      color: config.color,
      emissive: config.color,
      emissiveIntensity: 0.4
    })
  );
  enemyGroup.add(body);
  
  // „Éà„Ç≤Ôºà6ÊñπÂêëÔºâ
  const spikeSize = config.size * 0.4;
  const spikeGeometry = new THREE.ConeGeometry(spikeSize * 0.3, spikeSize, 4);
  const directions = [
    {x: config.size * 0.5, y: 0, z: 0, rx: 0, ry: 0, rz: -Math.PI/2},
    {x: -config.size * 0.5, y: 0, z: 0, rx: 0, ry: 0, rz: Math.PI/2},
    {x: 0, y: config.size * 0.5, z: 0, rx: 0, ry: 0, rz: 0},
    {x: 0, y: -config.size * 0.5, z: 0, rx: 0, ry: 0, rz: Math.PI},
    {x: 0, y: 0, z: config.size * 0.5, rx: Math.PI/2, ry: 0, rz: 0},
    {x: 0, y: 0, z: -config.size * 0.5, rx: -Math.PI/2, ry: 0, rz: 0}
  ];
  
  directions.forEach(dir => {
    const spike = new THREE.Mesh(
      spikeGeometry,
      new THREE.MeshStandardMaterial({
        color: config.color,
        emissive: config.color,
        emissiveIntensity: 0.6
      })
    );
    spike.position.set(dir.x, dir.y, dir.z);
    spike.rotation.set(dir.rx, dir.ry, dir.rz);
    enemyGroup.add(spike);
  });
  
  const angle = Math.random() * Math.PI * 2;
  const dist = ARENA_SIZE - 5;
  enemyGroup.position.set(
    Math.cos(angle) * dist,
    config.size/2,
    Math.sin(angle) * dist
  );
  
  enemyGroup.userData = {
    type: type,
    behavior: Math.floor(Math.random() * 4),
    speed: config.speed * (1 + waveNumber * 0.1),
    health: config.health,
    maxHealth: config.health,
    points: config.points,
    t: Math.random() * 5,
    angle: Math.random() * Math.PI * 2,
    targetAngle: 0,
    body: body // „ÉÄ„É°„Éº„Ç∏„Ç®„Éï„Çß„ÇØ„ÉàÁî®
  };
  
  enemyGroup.castShadow = true;
  scene.add(enemyGroup);
  enemies.push(enemyGroup);
  enemiesInWave++;
}

// „Éú„Çπ
function spawnBoss() {
  playSound('bossSpawn');
  
  const bossEnemy = new THREE.Mesh(
    new THREE.DodecahedronGeometry(2.5, 0),
    new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.7,
      metalness: 0.6
    })
  );
  
  bossEnemy.position.set(0, 2.5, -ARENA_SIZE + 10);
  bossEnemy.userData = {
    isBoss: true,
    health: 30 + waveNumber * 15,
    maxHealth: 30 + waveNumber * 15,
    speed: 2.0,
    phase: 0,
    t: 0,
    attackCooldown: 0
  };
  
  bossEnemy.castShadow = true;
  scene.add(bossEnemy);
  boss = bossEnemy;
  
  document.getElementById('boss-name').textContent = `BOSS WAVE ${waveNumber}`;
  document.getElementById('boss-name').style.display = 'block';
  document.getElementById('boss-health').style.display = 'block';
  updateBossHealth();
}

function updateBossHealth() {
  if(boss) {
    const percent = (boss.userData.health / boss.userData.maxHealth) * 100;
    document.getElementById('boss-health-bar').style.width = percent + '%';
  }
}

// WaveÁÆ°ÁêÜ
function startWave() {
  waveNumber++;
  enemiesInWave = 0;
  enemiesKilledInWave = 0;
  
  const enemyCount = 5 + waveNumber * 2;
  
  for(let i = 0; i < enemyCount; i++) {
    setTimeout(() => spawnEnemy(), i * 1000);
  }
  
  if(waveNumber % 3 === 0) {
    setTimeout(() => spawnBoss(), enemyCount * 1000 + 2000);
  }
}

startWave();

// =====================
// ÂÖ•Âäõ
// =====================
const key = {};
let mouseX = 0, mouseZ = 0;
let mouseDown = false;

addEventListener("keydown", e => {
  key[e.key.toLowerCase()] = true;
  if(e.code === 'Space' && !dashCooldown) {
    dashActive = true;
    dashCooldown = 1.0;
    playSound('dash');
  }
  if(e.key.toLowerCase() === 'shift') {
    activateSpecial();
  }
});
addEventListener("keyup", e => key[e.key.toLowerCase()] = false);

addEventListener("mousemove", e => {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  
  const vector = new THREE.Vector3(x, y, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const distance = -camera.position.y / dir.y;
  const pos = camera.position.clone().add(dir.multiplyScalar(distance));
  
  mouseX = pos.x;
  mouseZ = pos.z;
  reticle.position.x = mouseX;
  reticle.position.z = mouseZ;
});

addEventListener("mousedown", () => {
  mouseDown = true;
});

addEventListener("mouseup", () => {
  mouseDown = false;
});

let touchX = 0, touchY = 0;
addEventListener("touchmove", e => {
  const t = e.touches[0];
  touchX = (t.clientX/innerWidth - 0.5) * 2;
  touchY = (t.clientY/innerHeight - 0.5) * 2;
}, {passive: false});

addEventListener("touchstart", e => {
  const t = e.touches[0];
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((t.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((t.clientY - rect.top) / rect.height) * 2 + 1;
  
  const vector = new THREE.Vector3(x, y, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const distance = -camera.position.y / dir.y;
  const pos = camera.position.clone().add(dir.multiplyScalar(distance));
  
  shootBullet(pos.x, pos.z);
});

// =====================
// „Ç≤„Éº„É†Áä∂ÊÖã
// =====================
let score = 0;
let highscore = parseInt(localStorage.getItem('underwaterHighscore3') || '0');
let invincible = 3;
let speedBoost = 0;
let rapidFire = 0;
let scoreMultiplier = 1;
let combo = 0;
let comboTimer = 0;
let dashActive = false;
let dashCooldown = 0;

// ÂÆüÁ∏æ„Ç∑„Çπ„ÉÜ„É†
const achievements = {
  firstKill: {name: "ÂàùÊíÉÁ†¥", unlocked: false, check: () => enemiesKilledInWave >= 1},
  combo10: {name: "10„Ç≥„É≥„Éú", unlocked: false, check: () => combo >= 10},
  combo50: {name: "50„Ç≥„É≥„Éú", unlocked: false, check: () => combo >= 50},
  wave5: {name: "Wave 5Âà∞ÈÅî", unlocked: false, check: () => waveNumber >= 5},
  wave10: {name: "Wave 10Âà∞ÈÅî", unlocked: false, check: () => waveNumber >= 10},
  score1000: {name: "1000ÁÇπ", unlocked: false, check: () => score >= 1000},
  score5000: {name: "5000ÁÇπ", unlocked: false, check: () => score >= 5000},
  bossKiller: {name: "„Éú„ÇπÊíÉÁ†¥", unlocked: false},
  sharpshooter: {name: "100‰ΩìÊíÉÁ†¥", unlocked: false, check: () => totalKills >= 100}
};

let totalKills = 0;

function checkAchievements() {
  let newUnlock = false;
  Object.keys(achievements).forEach(key => {
    const ach = achievements[key];
    if(!ach.unlocked && ach.check && ach.check()) {
      ach.unlocked = true;
      newUnlock = true;
      showAchievement(ach.name);
    }
  });
  
  if(newUnlock) updateAchievementDisplay();
}

function showAchievement(name) {
  const msg = document.getElementById('msg');
  const oldText = msg.textContent;
  msg.textContent = `üèÜ ÂÆüÁ∏æËß£Èô§: ${name}`;
  msg.style.color = '#ffdd00';
  playSound('powerup');
  setTimeout(() => {
    msg.textContent = oldText;
    msg.style.color = '#ffd';
  }, 3000);
}

function updateAchievementDisplay() {
  const list = document.getElementById('achievement-list');
  const unlocked = Object.values(achievements).filter(a => a.unlocked).length;
  const total = Object.keys(achievements).length;
  list.innerHTML = `${unlocked}/${total} Ëß£Èô§Ê∏à„Åø`;
}

updateAchievementDisplay();

const scoreEl = document.getElementById("score");
const comboCountEl = document.getElementById("comboCount");
const waveEl = document.getElementById("wave");
const highscoreEl = document.getElementById("highscoreVal");
const msg = document.getElementById("msg");
const comboDisplay = document.getElementById("combo");

highscoreEl.textContent = highscore;
waveEl.textContent = waveNumber;

// =====================
// „Éü„Éã„Éû„ÉÉ„Éó
// =====================
const minimapCanvas = document.getElementById("minimap");
const minimapCtx = minimapCanvas.getContext("2d");
minimapCanvas.width = 180;
minimapCanvas.height = 180;

function drawMinimap() {
  minimapCtx.clearRect(0, 0, 180, 180);
  minimapCtx.fillStyle = 'rgba(11, 60, 93, 0.8)';
  minimapCtx.fillRect(0, 0, 180, 180);
  
  minimapCtx.strokeStyle = '#00ddff';
  minimapCtx.lineWidth = 2;
  minimapCtx.strokeRect(10, 10, 160, 160);
  
  const scale = 160 / (ARENA_SIZE * 2);
  const centerX = 90;
  const centerY = 90;
  
  function toMapCoords(x, z) {
    return {
      x: centerX + x * scale,
      y: centerY + z * scale
    };
  }
  
  const pPos = toMapCoords(player.position.x, player.position.z);
  minimapCtx.fillStyle = invincible > 0 ? '#00ffff' : '#ffffff';
  minimapCtx.beginPath();
  minimapCtx.arc(pPos.x, pPos.y, 5, 0, Math.PI*2);
  minimapCtx.fill();
  
  minimapCtx.fillStyle = '#ff4444';
  enemies.forEach(e => {
    const ePos = toMapCoords(e.position.x, e.position.z);
    minimapCtx.beginPath();
    minimapCtx.arc(ePos.x, ePos.y, 3, 0, Math.PI*2);
    minimapCtx.fill();
  });
  
  if(boss) {
    const bPos = toMapCoords(boss.position.x, boss.position.z);
    minimapCtx.fillStyle = '#ff0000';
    minimapCtx.beginPath();
    minimapCtx.arc(bPos.x, bPos.y, 7, 0, Math.PI*2);
    minimapCtx.fill();
    minimapCtx.strokeStyle = '#ffff00';
    minimapCtx.lineWidth = 2;
    minimapCtx.stroke();
  }
  
  minimapCtx.fillStyle = '#00ddff';
  powerups.forEach(p => {
    const pPos = toMapCoords(p.position.x, p.position.z);
    minimapCtx.beginPath();
    minimapCtx.arc(pPos.x, pPos.y, 3, 0, Math.PI*2);
    minimapCtx.fill();
  });
  
  minimapCtx.fillStyle = '#ffdd00';
  coins.forEach(c => {
    const cPos = toMapCoords(c.position.x, c.position.z);
    minimapCtx.beginPath();
    minimapCtx.arc(cPos.x, cPos.y, 2, 0, Math.PI*2);
    minimapCtx.fill();
  });
}

// =====================
// „É´„Éº„Éó
// =====================
let last = performance.now();
function loop(now) {
  const dt = Math.min((now - last) / 1000, 0.05);
  last = now;
  update(dt);
  drawMinimap();
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =====================
// Êõ¥Êñ∞
// =====================
function update(dt) {
  let baseSpeed = 10;
  if(speedBoost > 0) baseSpeed *= 1.8;
  if(dashActive) baseSpeed *= 4.0; // „ÉÄ„ÉÉ„Ç∑„É•„Çí„ÇÇ„Å£„Å®ÈÄü„Åè
  
  if(dashActive) {
    dashActive = false;
  }
  if(dashCooldown > 0) {
    dashCooldown -= dt;
  }
  if(shootCooldown > 0) {
    shootCooldown -= dt;
  }
  
  // ÁßªÂãï
  let vx = 0, vz = 0;
  if(key.w) vz -= 1;
  if(key.s) vz += 1;
  if(key.a) vx -= 1;
  if(key.d) vx += 1;
  
  const len = Math.hypot(vx, vz);
  if(len > 0) {
    vx /= len;
    vz /= len;
  }
  
  player.position.x += (vx + touchX) * baseSpeed * dt;
  player.position.z += (vz + touchY) * baseSpeed * dt;
  
  const margin = 1;
  player.position.x = Math.max(-ARENA_SIZE + margin, Math.min(ARENA_SIZE - margin, player.position.x));
  player.position.z = Math.max(-ARENA_SIZE + margin, Math.min(ARENA_SIZE - margin, player.position.z));
  
  // Â≤©ÂΩì„Åü„ÇäÂà§ÂÆö
  obstacles.forEach(o => {
    const dx = player.position.x - o.position.x;
    const dz = player.position.z - o.position.z;
    const dist = Math.hypot(dx, dz);
    const min = o.userData.radius + 0.7;
    if(dist < min) {
      const nx = dx / (dist + 0.001);
      const nz = dz / (dist + 0.001);
      player.position.x = o.position.x + nx * min;
      player.position.z = o.position.z + nz * min;
    }
  });
  
  if(len > 0) {
    player.rotation.y += dt * 5;
  }
  
  // Ëá™ÂãïÂ∞ÑÊíÉÔºà„Éû„Ç¶„ÇπÊäº‰∏ãÊôÇ or „É©„Éî„ÉÉ„Éâ„Éï„Ç°„Ç§„Ç¢ÊôÇÔºâ
  if(mouseDown || (rapidFire > 0 && enemies.length > 0)) {
    if(rapidFire > 0 && enemies.length > 0) {
      // ÊúÄ„ÇÇËøë„ÅÑÊïµ„ÇíÁãô„ÅÜ
      let nearest = enemies[0];
      let minDist = Infinity;
      enemies.forEach(e => {
        const d = Math.hypot(player.position.x - e.position.x, player.position.z - e.position.z);
        if(d < minDist) {
          minDist = d;
          nearest = e;
        }
      });
      shootBullet(nearest.position.x, nearest.position.z);
    } else {
      shootBullet(mouseX, mouseZ);
    }
  }
  
  // Âºæ‰∏∏Êõ¥Êñ∞ÔºàÊúÄÂ§ßÊï∞Âà∂Èôê„Åß„É°„É¢„É™„É™„Éº„ÇØÈò≤Ê≠¢Ôºâ
  if(bullets.length > 200) {
    // Âè§„ÅÑÂºæ‰∏∏„ÇíÂâäÈô§
    const toRemove = bullets.splice(0, 50);
    toRemove.forEach(b => {
      if(b && b.geometry) b.geometry.dispose();
      if(b && b.material) b.material.dispose();
      if(b && b.parent) scene.remove(b);
    });
  }
  
  // ÂâäÈô§„Åô„ÇãÂºæ‰∏∏„Çí„Éû„Éº„ÇØ
  const bulletsToRemove = [];
  
  for(let i = 0; i < bullets.length; i++) {
    const b = bullets[i];
    if(!b || !b.position) {
      bulletsToRemove.push(i);
      continue;
    }
    
    b.position.x += b.userData.vx * dt;
    b.position.z += b.userData.vz * dt;
    b.userData.life -= dt;
    
    if(b.userData.life <= 0 || 
       Math.abs(b.position.x) > ARENA_SIZE || 
       Math.abs(b.position.z) > ARENA_SIZE) {
      bulletsToRemove.push(i);
      continue;
    }
    
    // Êïµ„Å®„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
    let hitEnemy = false;
    for(let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if(!e || !e.position) continue;
      
      const dist = Math.hypot(b.position.x - e.position.x, b.position.z - e.position.z);
      
      if(dist < 1) {
        bulletsToRemove.push(i);
        hitEnemy = true;
        
        const damage = b.userData.damage || 1;
        e.userData.health -= damage;
        if(e.userData.body) {
          e.userData.body.material.emissiveIntensity = 1.0;
        }
        
        // ÂøÖÊÆ∫ÊäÄ„Ç≤„Éº„Ç∏„ÅØÊïµ„Å´ÂΩì„Åü„Å£„ÅüÊôÇ„ÅÆ„Åø„ÉÅ„É£„Éº„Ç∏
        specialMeter += 3;
        if(specialMeter > 100) specialMeter = 100;
        
        if(e.userData.health <= 0) {
          // „Ç∞„É´„Éº„Éó„Å®„Åù„ÅÆÂ≠êË¶ÅÁ¥†„ÇíÂÆåÂÖ®„Å´ÂâäÈô§
          e.traverse(child => {
            if(child.geometry) child.geometry.dispose();
            if(child.material) {
              if(Array.isArray(child.material)) {
                child.material.forEach(mat => mat.dispose());
              } else {
                child.material.dispose();
              }
            }
          });
          scene.remove(e);
          enemies.splice(j, 1);
          score += e.userData.points * (combo + 1) * scoreMultiplier;
          combo++;
          comboTimer = 3;
          enemiesKilledInWave++;
          totalKills++;
          playSound('enemyKill', combo);
          showCombo();
          
          // „Ç≥„Ç§„É≥„Éâ„É≠„ÉÉ„Éó
          if(Math.random() < 0.3) {
            const coin = new THREE.Mesh(
              new THREE.CylinderGeometry(0.5, 0.5, 0.15, 20),
              new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.6,
                metalness: 0.9
              })
            );
            coin.position.copy(e.position);
            coin.rotation.x = Math.PI/2;
            coin.userData = {t: 0};
            scene.add(coin);
            coins.push(coin);
          }
        }
        break;
      }
    }
    
    if(hitEnemy) continue;
    
    // „Éú„Çπ„Å®„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
    if(boss && boss.position) {
      const dist = Math.hypot(b.position.x - boss.position.x, b.position.z - boss.position.z);
      if(dist < 3) {
        bulletsToRemove.push(i);
        
        const damage = b.userData.damage || 1;
        boss.userData.health -= damage;
        boss.material.emissiveIntensity = 1.0;
        playSound('bossHit');
        updateBossHealth();
        
        // ÂøÖÊÆ∫ÊäÄ„Ç≤„Éº„Ç∏„ÅØ„Éú„Çπ„Å´ÂΩì„Åü„Å£„ÅüÊôÇ„ÇÇ„ÉÅ„É£„Éº„Ç∏
        specialMeter += 2;
        if(specialMeter > 100) specialMeter = 100;
        
        if(boss.userData.health <= 0) {
          if(boss.geometry) boss.geometry.dispose();
          if(boss.material) boss.material.dispose();
          scene.remove(boss);
          boss = null;
          score += 500 * scoreMultiplier;
          combo += 10;
          comboTimer = 5;
          totalKills++;
          playSound('powerup');
          achievements.bossKiller.unlocked = true;
          showAchievement("„Éú„ÇπÊíÉÁ†¥");
          
          document.getElementById('boss-name').style.display = 'none';
          document.getElementById('boss-health').style.display = 'none';
          
          for(let k = 0; k < 5; k++) {
            setTimeout(() => spawnCoin(), k * 200);
          }
          setTimeout(() => spawnPowerup(), 1000);
        }
      }
    }
  }
  
  // „Éû„Éº„ÇØ„Åó„ÅüÂºæ‰∏∏„ÇíÂâäÈô§ÔºàÈÄÜÈ†Ü„ÅßÂâäÈô§Ôºâ
  for(let i = bulletsToRemove.length - 1; i >= 0; i--) {
    const idx = bulletsToRemove[i];
    if(bullets[idx]) {
      const b = bullets[idx];
      if(b.geometry) b.geometry.dispose();
      if(b.material) b.material.dispose();
      scene.remove(b);
      bullets.splice(idx, 1);
    }
  }
  
  // Êµ∑Ëóª
  kelps.forEach(k => {
    k.userData.t += dt;
    k.rotation.z = Math.sin(k.userData.t) * 0.15;
  });
  
  // Ê≥°
  bubbles.forEach(b => {
    b.position.y += b.userData.speed * dt;
    if(b.position.y > 25) b.position.y = 0;
    b.userData.t = (b.userData.t || 0) + dt * 2;
    b.position.x += Math.sin(b.userData.t) * 0.8 * dt;
  });
  
  // „Ç≥„Ç§„É≥
  for(let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    c.userData.t += dt;
    c.rotation.y += dt * 4;
    c.position.y = 0.5 + Math.sin(c.userData.t * 2) * 0.3;
    
    const dx = player.position.x - c.position.x;
    const dz = player.position.z - c.position.z;
    const dist = Math.hypot(dx, dz);
    
    if(dist < 1.5) {
      scene.remove(c);
      coins.splice(i, 1);
      score += (50 + combo * 5) * scoreMultiplier;
      playSound('coin');
    }
  }
  
  // „Éë„ÉØ„Éº„Ç¢„ÉÉ„Éó
  for(let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.userData.t += dt;
    p.rotation.x += dt * 2;
    p.rotation.y += dt * 3;
    p.position.y = 0.5 + Math.sin(p.userData.t * 2) * 0.4;
    
    const dist = Math.hypot(
      player.position.x - p.position.x,
      player.position.z - p.position.z
    );
    
    if(dist < 1.8) {
      scene.remove(p);
      powerups.splice(i, 1);
      playSound('powerup');
      
      switch(p.userData.type) {
        case 'invincible':
          invincible = 6;
          scoreMultiplier = 2;
          setTimeout(() => { scoreMultiplier = 1; }, 6000);
          break;
        case 'speed':
          speedBoost = 8;
          break;
        case 'rapidfire':
          rapidFire = 10;
          break;
      }
    }
  }
  
  if(Math.random() < 0.0008 && powerups.length < 2) {
    spawnPowerup();
  }
  
  if(Math.random() < 0.002 && coins.length < 6) {
    spawnCoin();
  }
  
  // „Ç´„É°„É©ÔºàÂ¢ÉÁïåÂÜÖ„Å´Âà∂ÈôêÔºâ
  const targetCamX = player.position.x;
  const targetCamZ = player.position.z + 18;
  
  camera.position.x += (targetCamX - camera.position.x) * 0.1;
  camera.position.z += (targetCamZ - camera.position.z) * 0.1;
  
  // „Ç´„É°„É©„ÇíÂ¢ÉÁïåÂÜÖ„Å´Âà∂ÈôêÔºàÂ£Å„ÅÆÂÜÖÂÅ¥5mÔºâ
  const camMargin = 5;
  camera.position.x = Math.max(-ARENA_SIZE + camMargin, Math.min(ARENA_SIZE - camMargin, camera.position.x));
  camera.position.z = Math.max(-ARENA_SIZE + camMargin, Math.min(ARENA_SIZE - camMargin, camera.position.z));
  
  camera.lookAt(player.position);
  
  if(comboTimer > 0) {
    comboTimer -= dt;
    if(comboTimer <= 0) {
      combo = 0;
    }
  }
  
  // ÊïµAI
  for(let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if(!e || !e.userData) continue; // ÂÆâÂÖ®„ÉÅ„Çß„ÉÉ„ÇØ
    
    const dx = player.position.x - e.position.x;
    const dz = player.position.z - e.position.z;
    const dist = Math.hypot(dx, dz) + 0.001;
    
    e.rotation.y += dt * 5;
    e.userData.t += dt;
    
    switch(e.userData.behavior) {
      case 0:
        e.position.x += dx / dist * e.userData.speed * dt;
        e.position.z += dz / dist * e.userData.speed * dt;
        break;
      case 1:
        e.userData.targetAngle += dt * 3;
        const offset = Math.sin(e.userData.targetAngle) * 3;
        e.position.x += (dx / dist * e.userData.speed + offset) * dt;
        e.position.z += dz / dist * e.userData.speed * dt;
        break;
      case 2:
        e.userData.angle += dt * 2;
        const circleX = player.position.x + Math.cos(e.userData.angle) * 10;
        const circleZ = player.position.z + Math.sin(e.userData.angle) * 10;
        const toDx = circleX - e.position.x;
        const toDz = circleZ - e.position.z;
        const toDist = Math.hypot(toDx, toDz) + 0.001;
        e.position.x += toDx / toDist * e.userData.speed * dt;
        e.position.z += toDz / toDist * e.userData.speed * dt;
        break;
      case 3:
        if(Math.sin(e.userData.t * 1.5) > 0.5) {
          e.position.x += dx / dist * e.userData.speed * 1.5 * dt;
          e.position.z += dz / dist * e.userData.speed * 1.5 * dt;
        }
        break;
    }
    
    e.position.x = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, e.position.x));
    e.position.z = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, e.position.z));
    
    if(e.userData.body) {
      e.userData.body.material.emissiveIntensity = Math.max(0.4, e.userData.body.material.emissiveIntensity - dt * 2);
    }
    
    if(invincible <= 0 && dist < 1.2) {
      gameOver();
      return; // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂæå„ÅØÂá¶ÁêÜ„Çí‰∏≠Êñ≠
    }
  }
  
  // „Éú„ÇπAI
  if(boss && boss.userData) {
    const dx = player.position.x - boss.position.x;
    const dz = player.position.z - boss.position.z;
    const dist = Math.hypot(dx, dz) + 0.001;
    
    boss.userData.t += dt;
    boss.rotation.x += dt;
    boss.rotation.y += dt * 2;
    
    if(boss.userData.health > boss.userData.maxHealth * 0.5) {
      boss.position.x += dx / dist * boss.userData.speed * dt;
      boss.position.z += dz / dist * boss.userData.speed * dt;
    } else {
      boss.userData.phase = 1;
      boss.userData.speed = 4;
      const angle = boss.userData.t * 2;
      const radius = 20;
      boss.position.x = player.position.x + Math.cos(angle) * radius;
      boss.position.z = player.position.z + Math.sin(angle) * radius;
      
      boss.userData.attackCooldown -= dt;
      if(boss.userData.attackCooldown <= 0) {
        spawnEnemy();
        boss.userData.attackCooldown = 3;
      }
    }
    
    boss.material.emissiveIntensity = Math.max(0.7, boss.material.emissiveIntensity - dt * 2);
    
    if(invincible <= 0 && dist < 3) {
      gameOver();
      return; // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂæå„ÅØÂá¶ÁêÜ„Çí‰∏≠Êñ≠
    }
  }
  
  if(enemiesKilledInWave >= enemiesInWave && enemies.length === 0 && !boss) {
    startWave();
  }
  
  if(invincible > 0) {
    invincible -= dt;
    player.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
  } else {
    player.material.emissiveIntensity = 0.3;
  }
  
  if(speedBoost > 0) speedBoost -= dt;
  if(rapidFire > 0) rapidFire -= dt;
  
  let statusMsg = "";
  if(invincible > 0) statusMsg += "ÁÑ°Êïµ ";
  if(speedBoost > 0) statusMsg += "„Çπ„Éî„Éº„Éâ ";
  if(rapidFire > 0) statusMsg += "ÈÄ£Â∞Ñ ";
  if(scoreMultiplier > 1) statusMsg += `${scoreMultiplier}ÂÄç `;
  msg.textContent = statusMsg;
  
  score += dt * 15 * scoreMultiplier;
  scoreEl.textContent = Math.floor(score);
  comboCountEl.textContent = combo;
  waveEl.textContent = waveNumber;
  
  const specialPercent = (specialMeter / 100) * 100;
  document.getElementById('special-bar').style.width = specialPercent + '%';
  
  if(score > highscore) {
    highscore = Math.floor(score);
    highscoreEl.textContent = highscore;
  }
  
  checkAchievements();
}

function showCombo() {
  if(combo >= 3) {
    comboDisplay.textContent = `${combo} COMBO!`;
    comboDisplay.style.opacity = 1;
    comboDisplay.style.fontSize = Math.min(48 + combo * 2, 120) + 'px';
    setTimeout(() => {
      comboDisplay.style.opacity = 0;
    }, 500);
  }
}

function gameOver() {
  playSound('hit');
  
  if(score > highscore) {
    localStorage.setItem('underwaterHighscore3', Math.floor(score));
  }
  
  // ÂÖ®„Å¶„ÅÆÊïµ„ÇíÂÆåÂÖ®„Å´ÂâäÈô§
  enemies.forEach(e => {
    e.traverse(child => {
      if(child.geometry) child.geometry.dispose();
      if(child.material) {
        if(Array.isArray(child.material)) {
          child.material.forEach(mat => mat.dispose());
        } else {
          child.material.dispose();
        }
      }
    });
    scene.remove(e);
  });
  enemies = [];
  
  // Âºæ‰∏∏ÂâäÈô§
  bullets.forEach(b => {
    if(b.geometry) b.geometry.dispose();
    if(b.material) b.material.dispose();
    scene.remove(b);
  });
  bullets = [];
  
  // „Ç≥„Ç§„É≥ÂâäÈô§
  coins.forEach(c => {
    if(c.geometry) c.geometry.dispose();
    if(c.material) c.material.dispose();
    scene.remove(c);
  });
  coins = [];
  
  // „Éë„ÉØ„Éº„Ç¢„ÉÉ„ÉóÂâäÈô§
  powerups.forEach(p => {
    p.traverse(child => {
      if(child.geometry) child.geometry.dispose();
      if(child.material) {
        if(Array.isArray(child.material)) {
          child.material.forEach(mat => mat.dispose());
        } else {
          child.material.dispose();
        }
      }
    });
    scene.remove(p);
  });
  powerups = [];
  
  // „Éú„ÇπÂâäÈô§
  if(boss) {
    if(boss.geometry) boss.geometry.dispose();
    if(boss.material) boss.material.dispose();
    scene.remove(boss);
    boss = null;
    document.getElementById('boss-name').style.display = 'none';
    document.getElementById('boss-health').style.display = 'none';
  }
  
  // „Ç≤„Éº„É†Áä∂ÊÖã„É™„Çª„ÉÉ„Éà
  score = 0;
  combo = 0;
  waveNumber = 0;
  enemiesInWave = 0;
  enemiesKilledInWave = 0;
  specialMeter = 0;
  
  scoreEl.textContent = 0;
  comboCountEl.textContent = 0;
  
  player.position.set(0, 0.7, 0);
  
  invincible = 3;
  speedBoost = 0;
  rapidFire = 0;
  scoreMultiplier = 1;
  
  // Êñ∞„Åó„ÅÑWaveÈñãÂßã
  setTimeout(() => {
    startWave();
  }, 100);
}

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>